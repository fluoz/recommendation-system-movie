# -*- coding: utf-8 -*-
"""Sistem_rekomendasi.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Bm1dvePDe-1AtkPt4QfDLLTNIz8ShQj
"""

import pandas as pd
import numpy as np 
from google.colab import files
files.upload()

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json
!ls ~/.kaggle

!kaggle datasets download -d omkarborikar/top-10000-popular-movies

!mkdir dataset
!unzip -qq top-10000-popular-movies.zip -d dataset
!ls dataset

df = pd.read_csv("dataset/Top_10000_Movies.csv", lineterminator='\n')
df

df.info()

"""Hapus kolom yang tidak diperlukan"""

df.drop(["Unnamed: 0", "original_language", "tagline", "runtime", "revenue", "overview", "release_date", "vote_average", "vote_count", "popularity"], axis=1, inplace=True)

df.info()

"""banyak data awal"""

len(df.id.unique())

"""cek apakah ada missing value"""

df.isnull().sum()

df.loc[df["genre"] == '[]']

df = df.loc[df["genre"] != '[]']
df

fix_movie = df.sort_values('id', ascending=True)
fix_movie

# Membuang data duplikat pada variabel preparation
preparation = fix_movie.drop_duplicates('id')
preparation

# Mengonversi data series 'id' menjadi dalam bentuk list
movie_id = preparation['id'].tolist()
 
# Mengonversi data series 'original_title' menjadi dalam bentuk list
movie_name = preparation['original_title'].tolist()
 
# Mengonversi data series 'genre' menjadi dalam bentuk list
movie_genre = preparation['genre'].tolist()
 
print(len(movie_id))
print(len(movie_name))
print(len(movie_genre))

# Membuat dictionary untuk data ‘id’, ‘original_title’, dan ‘genre’
movie_new = pd.DataFrame({
    'id': movie_id,
    'movie_name': movie_name,
    'genre': movie_genre
})
movie_new

from sklearn.feature_extraction.text import TfidfVectorizer
 
# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()
 
# Melakukan perhitungan idf pada data genre
tf.fit(movie_new['genre']) 
 
# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(movie_new['genre']) 
 
# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

# Membuat dataframe untuk melihat tf-idf matrix
# Kolom diisi dengan jenis masakan
# Baris diisi dengan nama resto
 
pd.DataFrame(
    tfidf_matrix.todense(), 
    columns=tf.get_feature_names(),
    index=movie_new.movie_name
).sample(21, axis=1).sample(10, axis=0)

"""Cosine Similarity"""

from sklearn.metrics.pairwise import cosine_similarity
 
# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix) 
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto
cosine_sim_df = pd.DataFrame(cosine_sim, index=movie_new['movie_name'], columns=movie_new['movie_name'])
print('Shape:', cosine_sim_df.shape)
 
# Melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

def movie_recommendations(nama_movie, similarity_data=cosine_sim_df, items=movie_new[['movie_name', 'genre']], k=5):
    """
    Rekomendasi movie berdasarkan kemiripan dataframe
 
    Parameter:
    ---
    nama_movie : tipe data string (str)
                Nama movie (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan movie sebagai 
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---
 
 
    Pada index ini, kita mengambil k dengan nilai similarity terbesar 
    pada index matrix yang diberikan (i).
    """
 
 
    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan    
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,nama_movie].to_numpy().argpartition(
        range(-1, -k, -1))
    
    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    
    # Drop nama_movie agar nama movie yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_movie, errors='ignore')
 
    return pd.DataFrame(closest).merge(items).head(k)

movie_new[movie_new.movie_name.eq('Star Wars')]

# Mendapatkan rekomendasi movie yang mirip dengan Star Wars
movie_recommendations('Star Wars')